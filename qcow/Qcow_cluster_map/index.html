<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Qcow_cluster_map (qcow.Qcow_cluster_map)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">qcow</a> &#x00BB; Qcow_cluster_map</nav><h1>Module <code>Qcow_cluster_map</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>A cluster map which describes cluster usage in the file. The cluster map tracks which clusters are free, and which are used, and where the references are.</p></dd></dl><dl><dt class="spec type" id="type-move_state"><a href="#type-move_state" class="anchor"></a><code><span class="keyword">type</span> move_state</code><code> = </code><table class="variant"><tr id="type-move_state.Copying" class="anchored"><td class="def constructor"><a href="#type-move_state.Copying" class="anchor"></a><code>| </code><code><span class="constructor">Copying</span></code></td><td class="doc"><p>a background copy is in progress. If this cluster is modified then the copy should be aborted.</p></td></tr><tr id="type-move_state.Copied" class="anchored"><td class="def constructor"><a href="#type-move_state.Copied" class="anchor"></a><code>| </code><code><span class="constructor">Copied</span></code></td><td class="doc"><p>contents of this cluster have been copied once to another cluster. If this cluster is modified then the copy should be aborted.</p></td></tr><tr id="type-move_state.Flushed" class="anchored"><td class="def constructor"><a href="#type-move_state.Flushed" class="anchor"></a><code>| </code><code><span class="constructor">Flushed</span></code></td><td class="doc"><p>contents of this cluster have been copied and flushed to disk: it is now safe to rewrite the pointer. If this cluster is modified then the copy should be aborted.</p></td></tr><tr id="type-move_state.Referenced" class="anchored"><td class="def constructor"><a href="#type-move_state.Referenced" class="anchor"></a><code>| </code><code><span class="constructor">Referenced</span></code></td><td class="doc"><p>the reference has been rewritten; it is now safe to write to this cluster again. On the next flush, the copy is complete and the original block can be recycled.</p></td></tr></table></dt><dd><p>Describes the state of a block move</p></dd></dl><dl><dt class="spec type" id="type-reference"><a href="#type-reference" class="anchor"></a><code><span class="keyword">type</span> reference</code><code> = <a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a> * int</code></dt></dl><div class="spec module" id="module-Move"><a href="#module-Move" class="anchor"></a><code><span class="keyword">module</span> <a href="Move/index.html">Move</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-move"><a href="#type-move" class="anchor"></a><code><span class="keyword">type</span> move</code><code> = </code><code>{</code><table class="record"><tr id="type-move.move" class="anchored"><td class="def field"><a href="#type-move.move" class="anchor"></a><code>move : <a href="Move/index.html#type-t">Move.t</a>;</code></td></tr><tr id="type-move.state" class="anchored"><td class="def field"><a href="#type-move.state" class="anchor"></a><code>state : <a href="index.html#type-move_state">move_state</a>;</code></td></tr></table><code>}</code></dt><dd><p>describes the state of an in-progress block move</p></dd></dl><dl><dt class="spec value" id="val-string_of_move"><a href="#val-string_of_move" class="anchor"></a><code><span class="keyword">val</span> string_of_move : <a href="index.html#type-move">move</a> <span>&#45;&gt;</span> string</code></dt></dl><dl><dt class="spec type" id="type-cluster_state"><a href="#type-cluster_state" class="anchor"></a><code><span class="keyword">type</span> cluster_state</code><code> = </code><table class="variant"><tr id="type-cluster_state.Junk" class="anchored"><td class="def constructor"><a href="#type-cluster_state.Junk" class="anchor"></a><code>| </code><code><span class="constructor">Junk</span></code></td></tr><tr id="type-cluster_state.Erased" class="anchored"><td class="def constructor"><a href="#type-cluster_state.Erased" class="anchor"></a><code>| </code><code><span class="constructor">Erased</span></code></td></tr><tr id="type-cluster_state.Available" class="anchored"><td class="def constructor"><a href="#type-cluster_state.Available" class="anchor"></a><code>| </code><code><span class="constructor">Available</span></code></td></tr><tr id="type-cluster_state.Copies" class="anchored"><td class="def constructor"><a href="#type-cluster_state.Copies" class="anchor"></a><code>| </code><code><span class="constructor">Copies</span></code></td></tr><tr id="type-cluster_state.Roots" class="anchored"><td class="def constructor"><a href="#type-cluster_state.Roots" class="anchor"></a><code>| </code><code><span class="constructor">Roots</span></code></td><td class="doc"><p>The state of a cluster</p></td></tr></table></dt></dl><dl><dt class="spec value" id="val-set_cluster_state"><a href="#val-set_cluster_state" class="anchor"></a><code><span class="keyword">val</span> set_cluster_state : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Qcow_types/Cluster/IntervalSet/index.html#type-t">Qcow_types.Cluster.IntervalSet.t</a> <span>&#45;&gt;</span> <a href="index.html#type-cluster_state">cluster_state</a> <span>&#45;&gt;</span> <a href="index.html#type-cluster_state">cluster_state</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Update the state of a cluster</p></dd></dl><div class="spec module-type" id="module-type-MutableSet"><a href="#module-type-MutableSet" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MutableSet/index.html">MutableSet</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val</span> zero : <a href="index.html#type-t">t</a></code></dt><dd><p>A cluster map for a zero-length disk</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span>free:<a href="../Qcow_bitmap/index.html#type-t">Qcow_bitmap.t</a></span> <span>&#45;&gt;</span> <span>refs:<span><a href="index.html#type-reference">reference</a> <a href="../Qcow_types/Cluster/index.html#module-Map">Qcow_types.Cluster.Map</a>.t</span></span> <span>&#45;&gt;</span> <span>cache:<a href="../Qcow_cache/index.html#type-t">Qcow_cache.t</a></span> <span>&#45;&gt;</span> <span>first_movable_cluster:<a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a></span> <span>&#45;&gt;</span> <span>runtime_asserts:bool</span> <span>&#45;&gt;</span> <span>id:<span>string option</span></span> <span>&#45;&gt;</span> <span>cluster_size:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Given a set of free clusters, and the first cluster which can be moved (i.e. that isn't fixed header), construct an empty cluster map.</p></dd></dl><dl><dt class="spec value" id="val-total_used"><a href="#val-total_used" class="anchor"></a><code><span class="keyword">val</span> total_used : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int64</code></dt><dd><p>Return the number of tracked used clusters</p></dd></dl><dl><dt class="spec value" id="val-total_free"><a href="#val-total_free" class="anchor"></a><code><span class="keyword">val</span> total_free : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int64</code></dt><dd><p>Return the number of tracked free clusters</p></dd></dl><dl><dt class="spec value" id="val-resize"><a href="#val-resize" class="anchor"></a><code><span class="keyword">val</span> resize : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>resize t new_size_clusters</code> is called when the file is to be resized.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-reference">reference</a> <span>&#45;&gt;</span> <a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add t ref cluster</code> marks <code>cluster</code> as in-use and notes the reference from <code>reference</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>remove t cluster</code> marks <code>cluster</code> as free and invalidates any reference to it (e.g. in response to a discard)</p></dd></dl><dl><dt class="spec module" id="module-Junk"><a href="#module-Junk" class="anchor"></a><code><span class="keyword">module</span> <a href="Junk/index.html">Junk</a> : <a href="index.html#module-type-MutableSet">MutableSet</a></code></dt><dd><p>Clusters which contain arbitrary data</p></dd></dl><dl><dt class="spec module" id="module-Erased"><a href="#module-Erased" class="anchor"></a><code><span class="keyword">module</span> <a href="Erased/index.html">Erased</a> : <a href="index.html#module-type-MutableSet">MutableSet</a></code></dt><dd><p>Clusters which have been erased but haven't been flushed yet so can't be safely reallocated.</p></dd></dl><dl><dt class="spec module" id="module-Available"><a href="#module-Available" class="anchor"></a><code><span class="keyword">module</span> <a href="Available/index.html">Available</a> : <a href="index.html#module-type-MutableSet">MutableSet</a></code></dt><dd><p>Clusters which are available for reallocation</p></dd></dl><dl><dt class="spec module" id="module-Copies"><a href="#module-Copies" class="anchor"></a><code><span class="keyword">module</span> <a href="Copies/index.html">Copies</a> : <a href="index.html#module-type-MutableSet">MutableSet</a></code></dt><dd><p>Clusters which contain copies, as part of a compact</p></dd></dl><dl><dt class="spec module" id="module-Roots"><a href="#module-Roots" class="anchor"></a><code><span class="keyword">module</span> <a href="Roots/index.html">Roots</a> : <a href="index.html#module-type-MutableSet">MutableSet</a></code></dt><dd><p>Clusters which have been allocated but not yet placed somewhere reachable from the GC</p></dd></dl><dl><dt class="spec value" id="val-wait"><a href="#val-wait" class="anchor"></a><code><span class="keyword">val</span> wait : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p><code>wait t</code> wait for some amount of recycling work to become available, e.g.</p><ul><li>junk could be created</li><li>available could be used</li><li>a move might require a reference update</li></ul></dd></dl><dl><dt class="spec value" id="val-start_moves"><a href="#val-start_moves" class="anchor"></a><code><span class="keyword">val</span> start_moves : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Move/index.html#type-t">Move.t</a> list</span></code></dt><dd><p><code>start_moves t</code> calculates the block moves required to compact <code>t</code> and marks the clusters as moving</p></dd></dl><dl><dt class="spec value" id="val-moves"><a href="#val-moves" class="anchor"></a><code><span class="keyword">val</span> moves : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-move">move</a> <a href="../Qcow_types/Cluster/index.html#module-Map">Qcow_types.Cluster.Map</a>.t</span></code></dt><dd><p><code>moves t</code> returns the state of the current active moves</p></dd></dl><dl><dt class="spec value" id="val-set_move_state"><a href="#val-set_move_state" class="anchor"></a><code><span class="keyword">val</span> set_move_state : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Move/index.html#type-t">Move.t</a> <span>&#45;&gt;</span> <a href="index.html#type-move_state">move_state</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Update the state of the given move operation</p></dd></dl><dl><dt class="spec value" id="val-is_moving"><a href="#val-is_moving" class="anchor"></a><code><span class="keyword">val</span> is_moving : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_moving t cluster</code> returns true if <code>cluster</code> is still moving</p></dd></dl><dl><dt class="spec value" id="val-cancel_move"><a href="#val-cancel_move" class="anchor"></a><code><span class="keyword">val</span> cancel_move : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>cancel_move cluster</code> cancels any in-progress move of cluster <code>cluster</code>. This should be called with the cluster write lock held whenever there has been a change in the contents of <code>cluster</code></p></dd></dl><dl><dt class="spec value" id="val-complete_move"><a href="#val-complete_move" class="anchor"></a><code><span class="keyword">val</span> complete_move : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Move/index.html#type-t">Move.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>complete_move t move</code> marks the move as complete.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a> <span>&#45;&gt;</span> <a href="index.html#type-reference">reference</a></code></dt><dd><p><code>find t cluster</code> returns the reference to <code>cluster</code>, or raises <code>Not_found</code></p></dd></dl><dl><dt class="spec value" id="val-get_last_block"><a href="#val-get_last_block" class="anchor"></a><code><span class="keyword">val</span> get_last_block : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a></code></dt><dd><p><code>get_last_block t</code> is the last allocated block in <code>t</code>. Note if there are no data blocks this will point to the last header block even though it is immovable.</p></dd></dl><dl><dt class="spec value" id="val-is_immovable"><a href="#val-is_immovable" class="anchor"></a><code><span class="keyword">val</span> is_immovable : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_immovable t cluster</code> is true if <code>cluster</code> is fixed and cannot be moved i.e. it is before the first_movable_cluster i.e. it is part of the fixed (L1) header structure.</p></dd></dl><dl><dt class="spec value" id="val-update_references"><a href="#val-update_references" class="anchor"></a><code><span class="keyword">val</span> update_references : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Qcow_types/Cluster/index.html#type-t">Qcow_types.Cluster.t</a> <a href="../Qcow_types/Cluster/index.html#module-Map">Qcow_types.Cluster.Map</a>.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>update_references t subst</code> updates the reference table following the given set of substitutions. Any reference to a source block must be updated to the destination block otherwise it will be left pointing to junk. Normally this is guaranteed by the Metadata.Physical.set function, but when compacting we split the operation into phases and copy the block first at the byte level, leaving the map out-of-sync</p></dd></dl><dl><dt class="spec value" id="val-to_summary_string"><a href="#val-to_summary_string" class="anchor"></a><code><span class="keyword">val</span> to_summary_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_summary_string t</code> returns a terse printable summary of <code>t</code></p></dd></dl><div class="spec module" id="module-Debug"><a href="#module-Debug" class="anchor"></a><code><span class="keyword">module</span> <a href="Debug/index.html">Debug</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>